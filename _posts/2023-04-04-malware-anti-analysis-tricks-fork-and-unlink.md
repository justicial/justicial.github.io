---
layout: post
title: "Malware Anti-Analysis Tricks: fork and unlink"
date: 2023-04-04 8:00:00
categories: macOS Malware-Analysis
---
In this post, we'll take a look at a simple example of malware anti-analysis logic in C code.

Let's consider the following example:
{% highlight C %}
int main(int argc, const char * argv[]) {
    if (fork() == 0) {
            // run the program logic

            unlink(argv[0]);
    }
    return 0;
}
{% endhighlight %}

Within this code, we see some basic malware anti-analysis logic. It starts with creating a child process by calling `fork()` function. Then the main process exits, and the logic of the program executes in the child process and finishes with the removal of the executable.

**fork()** creates a new process by duplicating the calling process. The new process is referred to as the child process. The calling process is referred to as the parent process. Using `fork()` in that context slightly complicates debugging, as forking creates a new process. By exiting the parent process after the child process is created, the program simulates quick and successful execution with doing nothing. The debugger will also exit with the main process. Thus this trick will require additional manipulations with debugging to follow the child process.

The **unlink()** function removes the link named by path from its directory and decrements the link count of the file, which was referenced by the link. If that decrement reduces the link count of the file to zero, and no process has the file open, then all resources associated with the file are reclaimed. If one or more processes have the file open when the last link is removed, the link is removed, but the removal of the file is delayed until all references to it have been closed.

Self-deletion via `unlink` can thwart file-based antivirus scanners, or simply make it harder to find/grab the binary for analysis.

It's important to note that this example is just one small part of the larger field of malware analysis and anti-analysis. There are many other techniques that malware authors can use to evade detection and analysis, and analysts must continually develop new methods to keep up with the evolving threat landscape.

**In conclusion**, understanding malware anti-analysis logic is an essential part of analyzing and detecting malware. By exploring and experimenting with these techniques, analysts can better protect their systems and data from malicious attacks.